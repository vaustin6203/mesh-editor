<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<style>
  body {
    padding: 100px;
    width: 1000px;
    margin: auto;
    text-align: left;
    font-weight: 300;
    font-family: 'Open Sans', sans-serif;
    color: #2d5986;
    background-color: #f2e6ff;
  }
  h1, h2, h3, h4 {
    font-family: 'Source Sans Pro', sans-serif;
    color: #73264d;
  }

  table {
    table-layout: fixed;
    width: 100%;
    border-collapse: collapse;
    border: 3px solid purple;
  }

  thead th:nth-child(1) {
    width: 30%;
  }

  thead th:nth-child(2) {
    width: 20%;
  }

  thead th:nth-child(3) {
    width: 15%;
  }

  thead th:nth-child(4) {
    width: 35%;
  }

  th, td {
    padding: 20px;
  }

</style>
<title>CS 184 Mesh Editor</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link href="https://fonts.googleapis.com/css?family=Open+Sans|Source+Sans+Pro" rel="stylesheet">
</head>


<body>

<h1 align="middle">CS 184: Computer Graphics and Imaging, Spring 2017</h1>
<h1 align="middle">Project 2: Mesh Editor</h1>
<h2 align="middle">Victoria Austin, CS184-vaustin6203</h2>

<br><br>

<div>

  <center>
    <img src="images/thumbNail.png" align="middle" width="750px"/>
  </center>

<h2 align="middle">Overview</h2>
<p>
  In this project I explored various triangle mesh operations. Triangle meshes are a data structure that describes the shape of a graphic object through triangles.
  In order to render objects with smooth surfaces, I implemented de Casteljau's algorithm to interpolate Bezier curves and surfaces. I also made a program that finds
  the unit normal of a given vertex in a triangle mesh in order to apply Phong shading to smooth surfaces. This allows for smoother gradients of shading on smooth surfaces.
  I also implemented the local mesh operations that flip or split an edge in the mesh and used these operations the implement upsampling of triangle meshes using subdivision.
  I then explored different techniques for pre-processing a mesh before subdividing it in order to preserve particular structural properties of the original mesh.
</p>





<h2 align="middle">Section I: Bezier Curves and Surfaces</h2>

<h3 align="middle">Part 1: Bezier curves with 1D de Casteljau subdivision</h3>

<p>
  de Casteljau's algorithm is a method used to generate a smooth Be'zier curve based on a series of control points. The number of control points corresponds to the degree of the Be'zier Curve, where given n control points,
  the algorithm will create a Be'zier curve of degree n - 1. To find f(t) on a curve for parameter t ranging from zero to one, we iterate through the n control points to create a new set of n - 1 points by using linear
  interpolation. We interpolate the points p_i and p_i+1 by the formula : (1 - t)p_i + tp_i+1. We continue this iteration until we have a single point f(t) for the Be'zier curve defined by the initial set of control points.
</p>

<center>
<div align="middle">
  <table style="width=100%">
    <tr>
      <td>
        <img src="images/bezier1.png" align="middle" width="400px"/>
        <figcaption align="middle">Here is an image of the original 6 control points before de Casteljau's algorithm begins.</figcaption>
      </td>
      <td>
        <img src="images/bezier2.png" align="middle" width="400px"/>
        <figcaption align="middle">The first iteration of de Casteljau's algorithm. Notice the 5 new points weighted between the original 6. The green line represents the Be'zier curve at this iteration.</figcaption>
      </td>
    </tr>
    <br>
    <tr>
      <td>
        <img src="images/bezier3.png" align="middle" width="400px"/>
        <figcaption align="middle">The second iteration of de Casteljau's algorithm.</figcaption>
      </td>
      <td>
        <img src="images/bezier4.png" align="middle" width="400px"/>
        <figcaption align="middle">The third iteration of de Casteljau's algorithm.</figcaption>
      </td>
    </tr>
    <br>
    <tr>
      <td>
        <img src="images/bezier5.png" align="middle" width="400px"/>
        <figcaption align="middle">The fourth iteration of de Casteljau's algorithm.</figcaption>
      </td>
      <td>
        <img src="images/bezier6.png" align="middle" width="400px"/>
        <figcaption align="middle">The fifth and final iteration of Casteljau's alrgorithm. The red point is the final point generated by the algorithm and composes the complete Be'zier curve.</figcaption>
      </td>
    </tr>
  </table>
</div>
  </center>


  <center>
    <div align="middle">
      <table style="width=100%">
        <tr>
          <td>
            <img src="images/bezier7a.png" align="middle" width="400px"/>
            <figcaption align="middle">In this image, I moved the original control points to create a different Be'zier curve.</figcaption>
          </td>
          <td>
            <img src="images/bezier7b.png" align="middle" width="400px"/>
            <figcaption align="middle">With the modified control points, I then modified the parameter t to demonstrate how it changes the curve.</figcaption>
          </td>
        </tr>
        <br>
        <tr>
          <td>
            <img src="images/bezier7c.png" align="middle" width="400px"/>
            <figcaption align="middle">This is another example of modifying the parameter t.</figcaption>
          </td>
          <td>
            <img src="images/bezier8a.png" align="middle" width="400px"/>
            <figcaption align="middle">With the parameter t from the previous image, I modified the control points again.</figcaption>
          </td>
        </tr>
        <br>
        <tr>
          <td>
            <img src="images/bezier8b.png" align="middle" width="400px"/>
            <figcaption align="middle">I modified the parameter t again from the previous image to create this final curve.</figcaption>
          </td>
        </tr>
      </table>
    </div>
  </center>

  <h3 align="middle">Part 2: Bezier surfaces with separable 1D de Casteljau subdivision</h3>

  <center>
    <img src="images/beziergraph.png" align="middle" width="500px"/>
  </center>

<p>
 In order to be able to create smooth Be'zier surfaces, I extended de Casteljau's algorithm to apply to 3D surfaces. If we think of the control points as an n x n grid with each row representing a Bezier curve with the parameter u, we can apply de Casteljau's algorithm to
  each row and iteratively find the points f(u) that represents the Be'zier curve of each row. Then, given these f(u) points, we can apply de Casteljau's algorithm again with the parameter v in order to find the Be'zier surface f(u, v). The image above is a visualization that depicts
  each row as a Be'zier curve on the grid, which then get connected to create the Be'zier surface.
</p>


  <center>
    <img src="images/teapot.png" align="middle" width="400px"/>
  </center>
  <center>
    <p>
      This teapot is an example of a Be'zier surface rendered with my implementation of de Casteljau's algorithm.
    </p>
  </center>

<h2 align="middle">Section II: Sampling</h2>

<h3 align="middle">Part 3: Average normals for half-edge meshes</h3>
<p>
  For Part 3, I implemented finding the unit normal at a given vertex in order to apply Phong shading to provide shading for smooth surfaces. To compute the unit normal of a vertex, I used the halfEdgeMesh data structure to find the half-edge of the vertex along with the vertices of the neighboring triangles.
  Let a be the given vertex, b be the vertex of a's half-edge twin, and c be the vertex of a's next next half-edge. Each vertex is assigned a face and for each face, I weighted its normal by its area. To compute this,
  I took the dot product of the cross product of b-a and c-a to get the normal vector and then found its Euclidean length. Lastly, I summed all these weighted normals together and returned its normalized unit vector.
</p>

  <center>
    <div align="middle">
      <table style="width=100%">
        <tr>
          <td>
            <img src="images/teapotNoNorm.png" align="middle" width="400px"/>
            <figcaption align="middle">This is the teapot shaded without using vertex normals.</figcaption>
          </td>
          <td>
            <img src="images/normTeapot.png" align="middle" width="400px"/>
            <figcaption align="middle">This is the teapot shaded with vertex normals, notice the difference in smoothness from the previous image.</figcaption>
          </td>
        </tr>
      </table>
    </div>
  </center>

<h3 align="middle">Part 4: Half-edge flip</h3>

  <center>
    <img src="images/flip_vis1.png" align="middle" width="600px"/>
  </center>

<p>
For part 4, I implemented the local mesh operation of being able to flip an edge between two neighboring triangles. Given the edge we want to flip, I first check that the edge's half-edge and its twin half-edge in not on the boundary of the mesh, since flipping a bounding
  edge will disrupt the structure of the mesh. I then initialized all the original attributes of the edge including: all the half-edges of the given edge's face along with all their twin half-edges, all the half-edges of the twin half-edge
  of the half-edge of the given edge along with all their twin half-edges, all the edges associated with these half-edges, all their vertices, and the twin face. Then for all the half-edges, edges, vertices, and faces that change position
  and don't change position relative to the flipped edge, I reassigned their mesh attributes to ensure the validity of the local mesh structure. In order to check that my implementation was correct, I preformed multiple edge flips and started
  to notice some odd behavior. Notably, edges in the case where the edge should have disappeared after a flip, were remaining in the mesh and obstructing its structure. Thankfully, I noticed this pattern and realized that I had not reassigned the half-edges
  of the edges of the local mesh. This resolved my bug and ensured that edge attributes were getting assigned correctly.
</p>

  <center>
    <div align="middle">
      <table style="width=100%">
        <tr>
          <td>
            <img src="images/teapot_zoom.png" align="middle" width="400px"/>
            <figcaption align="middle">This is the teapot before flipping any edges.</figcaption>
          </td>
          <td>
            <img src="images/flipedge.png" align="middle" width="400px"/>
            <figcaption align="middle">This is the teapot after doing several various edge flips.</figcaption>
          </td>
        </tr>
      </table>
    </div>
  </center>


<h3 align="middle">Part 5: Half-edge split</h3>

  <center>
    <img src="images/splitVis.png" align="middle" width="600px"/>
  </center>

  <p>
    An edge split is an operation that splits an edge at its midpoint, resulting in two new triangle faces. To implement the edge split operation, I first checked that the edge's half-edge and twin were not on the boundary of the mesh. Afterwards, I found of all the original mesh attributes neighboring the given edge in a similar fashion to part 4.
    I then initialized six new half-edges, three new edges, three new faces, and a new vertex that I will assign to the mesh after we split the edge. From there, I split the edge by finding the midpoint of the given edge and set it as the position of the new vertex.
    I then assigned all of these new and old attributes to each other in a manner that maintained a valid mesh structure. After that, I assigned half-edges to all the faces, edges, and vertices and returned the new vertex. Luckily after I implemented the split operation, after performing various split and flip operations on the teapot triangle mesh,
    everything seemed to be working as expected, so I did not have to delve into any major debugging strategies.
  </p>

  <center>
    <div align="middle">
      <table style="width=100%">
        <tr>
          <td>
            <img src="images/teapot_zoom.png" align="middle" width="400px"/>
            <figcaption align="middle">This is the teapot triangle mesh before any edge split operations.</figcaption>
          </td>
          <td>
            <img src="images/teapotSplit.png" align="middle" width="400px"/>
            <figcaption align="middle">This is the same teapot after performing splitting on various edges of the mesh.</figcaption>
          </td>
        </tr>
        <br>
        <tr>
          <td>
            <img src="images/teapot_zoom.png" align="middle" width="400px"/>
            <figcaption align="middle">This again, is the teapot in its original form.</figcaption>
          </td>
          <td>
            <img src="images/teapotSplitFlip.png" align="middle" width="400px"/>
            <figcaption align="middle">This is the teapot after doing a bunch of flip and split operations to the edges of the mesh.</figcaption>
          </td>
        </tr>
      </table>
    </div>
  </center>


<h3 align="middle">Part 6: Loop subdivision for mesh upsampling</h3>

  <p>
    In order to do mesh upsampling, I implemented an algorithm known as loop subdivision. Loop subdivision is the process of subdividing each triangle in the mesh into four triangles by splitting every original edge of the mesh, flipping all new
    edges that connect an old vertex into a new vertex, and then updating the positions of all the vertices. However, to implement loop subdivision, I first calculated the positions of the original vertices and stored the position as a temporary variable
    in the vertices and calculated the positions of the new vertices and stored those positions as a temporary variable at its edge, in order to update the new positions of all the vertices after splitting and flipping. I did this in order to be able to iterate
    through the simplified mesh rather than the subdivided mesh with more elements. While iterating through the edges of the mesh and splitting original edges, I made sure to set the position of the new vertex created by the split to the new position that was stored at the edge.
    Additionally, in order to ensure that I would only flip new edges that were connected to a new and old vertices, I set the original edge, that is now split into two edges, as old edges and the two new edges that emerged from the split as new edges. My first attempt at implementing
    loop subdivision had only set the new vertex made by the split to new, which was causing me to flip too many edges and distort the mesh. After flipping the proper edges, I updated all the vertex positions to their new positions, which completed the subdivision.
  </p>


  <h3 align="middle">Upsampling an Organic Shape</h3>
  <center>
    <div align="middle">
      <table style="width=100%">
        <tr>
          <td>
            <img src="images/beastOG.png" align="middle" width="400px"/>
            <figcaption align="middle">This is a mesh of a beast before subdivision.</figcaption>
          </td>
          <td>
            <img src="images/beastSub.png" align="middle" width="400px"/>
            <figcaption align="middle">This is the mesh of the beast after subdivision. Notice that any sharp corners or edges from the beast have been smoothed. In some circumstances, we may want this effect. For example, this beast looks arguably better than the original do to the organic nature of the best. However, when sharp edges are more critical to the geometry of the object, rounding these edges is undesirable. Perhaps this could be solved by pre-splitting sharp corners and edges, so they do not get further split and flipped when we subdivide the mesh.</figcaption>
          </td>
        </tr>
      </table>
    </div>
  </center>



  <h3 align="middle">Upsampling a Cube</h3>
    <div align="middle">
      <table style="width=100%">
        <tr>
          <td>
            <img src="images/cubeOG.png" align="middle" width="400px"/>
            <figcaption align="middle">For example, this is a cube before subdivision. If the edges of this cube get smoothed, it will not look like a cube anymore.</figcaption>
          </td>
          <td>
            <img src="images/cubeSub1.png" align="middle" width="400px"/>
            <figcaption align="middle">Here is the cube after one subdivision, and it looks like a weird sharply edged ball. </figcaption>
          </td>
        </tr>
        <br>
        <tr>
          <td>
            <img src="images/cubeSub2.png" align="middle" width="400px"/>
            <figcaption align="middle">This is the cube after a second round of subdivision, and it is starting to become asymmetrical.</figcaption>
          </td>
          <td>
            <img src="images/cubeSub3.png" align="middle" width="400px"/>
            <figcaption align="middle">This is the cube after three subdivisions and it is developing into a irregularly shaped blob.</figcaption>
          </td>
        </tr>
        <br>
        <tr>
          <td>
            <img src="images/cubeSub4.png" align="middle" width="400px"/>
            <figcaption align="middle">This is now the cube after four subdivisions and it is continuing to get rounder and more irregular </figcaption>
          </td>
          <td>
            <img src="images/cubeSub5.png" align="middle" width="400px"/>
            <figcaption align="middle">This is the cube after 5 subdivisions, and it looks nothing like the sharply edged symmetrical shape it once was. I will now pre-spit the face edges of the cube before subdividing to see if this helps maintain the structure of the cube.</figcaption>
          </td>
        </tr>
      </table>
    </div>



  <h3 align="middle">Pre-Splitting and Upsampling a Cube</h3>
    <div align="middle">
      <table style="width=100%">
        <tr>
          <td>
            <img src="images/cubePSub1.png" align="middle" width="400px"/>
            <figcaption align="middle">This is the cube after pre-splitting all of the edges on the face of the cube and then doing one subdivision.</figcaption>
          </td>
          <td>
            <img src="images/cubePSub4.png" align="middle" width="400px"/>
            <figcaption align="middle">This is the same cube after doing four subdivisions. The resulting shape is more circular and symmetric. By pre-splitting the surface edges of the cube, the resulting new edges made the mesh on the faces of the cube more symmetrical in that they formed an 'X' shape on the face rather than a diagonal line. This allowed our subdivisions to maintain the symmetry of the cube. Now lets see if we can also preserve the corners of the cube by flipping its corner edges.</figcaption>
          </td>
        </tr>
      </table>
    </div>



  <h3 align="middle">Pre-Splitting, Pre-Flipping, and Upsampling a Cube</h3>
  <center>
    <div align="middle">
      <table style="width=100%">
        <tr>
          <td>
            <img src="images/cubePre.png" align="middle" width="400px"/>
            <figcaption align="middle">This is the cube pre-processed by splitting the surface edges and flipping all corner edges. Notice that this pre-processing has emphasized the sharp corner edges of the cube.</figcaption>
          </td>
          <td>
            <img src="images/cubePre1.png" align="middle" width="400px"/>
            <figcaption align="middle">This is the pre-processed cube after one subdivision and the mesh appears to be maintaining its corners and symmetry.</figcaption>
          </td>
        </tr>
        <br>
        <tr>
          <td>
            <img src="images/cubePre2.png" align="middle" width="400px"/>
            <figcaption align="middle">This is the cube after two subdivisions.</figcaption>
          </td>
          <td>
            <img src="images/cubePre3.png" align="middle" width="400px"/>
            <figcaption align="middle">This is the cube after three subdivisions.</figcaption>
          </td>
        </tr>
        <br>
        <tr>
          <td>
            <img src="images/cubePre4.png" align="middle" width="400px"/>
            <figcaption align="middle">This is the cube after four subdivisions and it still looks like a cube! By flipping the corner edges we were able to preserve the corners of the cube since flipping the corners made the edges protrude more. Then by subdividing, the inverted edges expanded and filled the space between each corner, resulting in an upsampled cube!</figcaption>
          </td>
        </tr>
      </table>
    </div>
  </center>



<h2 align="middle">Section III: Shaders</h2>

<h3 align="middle">Part 7: Fun with shaders</h3>


<h2 align="middle">Section IV: Mesh Competition</h2>
<p>If you are not participating in the optional mesh competition, don't worry about this section!</p>

<h3 align="middle">Part 8: Design your own mesh!</h3>

</body>
</html>
